using SecondColl.Properties;
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Data;
using System.Drawing;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Windows.Forms;

namespace SecondColl
{
    public partial class SortInfo : Form
    {
        string sortType;
        public SortInfo(string sortType)
        {
            this.sortType = sortType;
            InitializeComponent();
        }

        private void SortInfo_Load(object sender, EventArgs e)
        {
            if (sortType == "odd-even")
            {
                label2.Text = "Четная нечетная сортировка";
                mainText.Text = "Четно-нечетная транспозиционная сортировка (Even-Odd Transposition Sort) является параллельным алгоритмом сортировки, который используется для эффективной сортировки в параллельных средах, таких как распределенные и параллельные системы. Она производит сравнение и обмен соседних элементов в массиве для его упорядочения.";

                workingFlowText.Text = "1. Четные и нечетные фазы: Алгоритм выполняет чередующиеся четные и нечетные фазы.\r\n" +
                    "2. Сравнение и обмен элементов: На четной фазе каждый четный элемент сравнивается с его следующим (четным) соседом, и они обмениваются, если это необходимо для упорядочивания.\r\n" +
                    "3. Обратное сравнение и обмен на нечетной фазе: На нечетной фазе каждый нечетный элемент сравнивается с его следующим (нечетным) соседом, и они обмениваются, если это необходимо для упорядочивания.\r\n" +
                    "4. Параллелизм: Этот алгоритм может быть эффективно распараллелен, так как четные и нечетные фазы могут быть выполнены параллельно.";
                sortSpeedText.Text = "Сложность четно-нечетной транспозиционной сортировки зависит от реализации, но она обычно имеет сложность O(log**2n) для сортировки n элементов в худшем случае.";

                sortGif.Image = Resources.odd_even_transposition_sort;
            }
            else if (sortType == "gnome")
            {
                label2.Text = "Гномья сортировка";
                mainText.Text = "Гномья сортировка (Gnome Sort) - это простой алгоритм сортировки, который проходит через список элементов, сравнивая текущий элемент со следующим. Если они в правильном порядке, алгоритм продвигается на одну позицию вперед. В противном случае он меняет их местами и возвращается на одну позицию назад. Этот процесс повторяется до тех пор, пока весь список не будет отсортирован.";

                workingFlowText.Text = "1. Итерация по списку: Алгоритм начинает с индекса 0. Он сравнивает текущий элемент с предыдущим.\r\n" +
                    "2. Движение по списку: Если элементы в правильном порядке, алгоритм движется вперед на один элемент. Если элементы не в правильном порядке, они меняются местами, и алгоритм возвращается на одну позицию назад.\r\n" +
                    "3. Повторение: Процесс повторяется для всех элементов до тех пор, пока весь список не будет отсортирован.";
                sortSpeedText.Text = "Сложность гномьей сортировки в худшем случае и среднем случае составляет О(n**2), где n - количество элементов в списке. Это делает ее менее эффективной, чем более эффективные алгоритмы сортировки, такие как быстрая сортировка (O(nlogn)) или сортировка слиянием (О(nlogn)).";

                sortGif.Image = Resources.gnome_sort;


            }
            else if (sortType == "bitonic")
            {
                label2.Text = "Битоническая сортировка";
                mainText.Text = "Битоническая сортировка (Bitonic Sort) — это параллельный алгоритм сортировки, " +
                "который эффективен для использования в параллельных вычислениях. " +
                "Основан на разделении последовательности на битонические последовательности " +
                "(последовательности, которые сначала возрастают, а затем убывают).";

                workingFlowText.Text = "1. Разделение на битонические последовательности: Последовательность делится на две части, каждая из которых является битонической (возрастающей, затем убывающей).\r\n\r\n2. Слияние битонических последовательностей: Затем битонические последовательности сливаются (merge) в порядке, соответствующем двоичным битам позиции элемента.";
                sortSpeedText.Text = "В худшем случае битоническая сортировка выполняется за O(log**2n), где n — количество элементов в последовательности. Она обладает высоким потенциалом параллелизма и может быть реализована с использованием параллельных алгоритмов для оптимизации производительности.";


                sortGif.Image = Resources.bitonic_sort;
            }
            else
            {
                label2.Text = "Bug";
            }
        }

        private void label2_Click(object sender, EventArgs e)
        {

        }

        private void workingFlowText_Click(object sender, EventArgs e)
        {

        }

        private void flowLayoutPanel1_Paint(object sender, PaintEventArgs e)
        {

        }

        private void sortSpeedText_Click(object sender, EventArgs e)
        {

        }
    }
}
